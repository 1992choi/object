# object
## 프로젝트 구조
### object-basic
  - Inflearn > 오브젝트 - 기초편
    - org.eternity 패키지
      - 예제 2.1
      - 예제 2.4
    - org.eternity_ex5 패키지
      - 예제 5.1
      - 예제 5.3
    - https://github.com/eternity-oop/object-basic-05-04
      - 예제 5.4
    - https://github.com/eternity-oop/object-basic-06-06
      - 예제 6.6

<hr>

## 오브젝트 - 기초편
### 절차적인 설계 및 구현
- 절차적인 설계는 로직을 실행 순서대로 클래스 안에 모두 배치한다.
- 데이터가 사용될 문맥을 고려하지 않은 채 설계된다.
- 이로인하여 중앙집중식 제어 스타일이된다.
  - 서비스에서 모든 DAO와 도메인을 호출하는 스타일
  - 만약 데이터를 구현하는 코드가 수정될 때, 다른 코드까지 함께 수정될 가능성이 높다.
  - Ex) 특정 DTO객체에 유효한 날짜 계산을 위한 변수 startDay, endDay가 있다고 가정할 때,   
    getter를 통해 startDay와 endDay를 제공하고 이를 서비스에서 계산을 한다면,   
    변수명이 바뀌거나 판단 기준이 변경되었을 때 서비스 로직까지 수정에 여파가 발생한다.   
    만약 DTO 내부에서 변수를 가지고 유효한지 아닌지의 값만 제공한다면   
    변수명 혹은 판단 기준 변경에 따라 서비스 로직까지 수정되는 일은 없을 것이다.
    - 따라서 데이터를 사용하는 프로세스는 데이터 내부(DTO)로 이동해야한다.
    - 아래 '캡슐화 위반'과 비슷한 맥락.  
- 캡슐화 위반
  - 단순하게 getter와 setter를 제공한다고 캡슐화가 완성되는 것은 아니다.
  - 각각의 데이터가 어떤 문맥에서 사용될지도 모르기 때문에, 데이터가 변경되면 파급효과가 클 수도 있다.
  - 이는 캡슐화를 위반한 것으로도 볼 수 있다.

<br><br><br>

### 객체지향 설계 원칙
- 설계가 필요한 이유
  - 요구사항이 변경 될 때 코드를 쉽고 안전하게 수정하기 위해.
- 객체지향 설계 원칙
  - 협력에 필요한 행동을 먼저 결정하고 행동에 적합한 객체를 나중에 선택.
  - 객체의 행동을 먼저 구현하고 행동에 필요한 데이터를 나중에 선택.
- 책임을 기반으로 설계 (=책임 주도 설계)
  - 애플리케이션이 제공할 기능 파악
  - 애플리케이션의 기능 요구사항을 시스템의 책임으로 변환
  - 시스템의 책임을 객체의 책임으로 변환
  - 책임을 담당할 적절한 객체 선택
  - 객체의 책임이 외부의 도움이 필요하다면 다른 객체에게 도움을 요청
  - 도움이 필요한 (=책임을 담당할) 적절한 객체를 선택

<br><br><br>

### GRASP
- General Responsibility Assignment Software Patterns의 약자로 일반적인 책임 할당을 위한 소프트웨어 패턴을 뜻한다.
- 종류
  - Creator
  - Information Expert 
  - Controller
  - Low Coupling
  - High Cohesion
  - Indirection
  - Polymorphism
  - Protected Variations
  - Pure Fabrication
- Ref. https://lob-dev.tistory.com/47

<br><br><br>

### 설계
- 설계란?
  - 설계는 굉장히 대단한 것이 아닐 수 있다.
  - 간단한 관점에서 바라보면 코드를 배치하는 방식이다.
- 훌륭한 설계
  - 응집도가 높다.
  - 결합도가 낮다.
  - 캡슐화를 지키도록 코드를 배치한다.
- 응집도
  - 모듈 내부 요소들 사이의 기능적인 집중도
  - 모듈 내부의 데이터와 메서드 간에 관련된 정도
  - 응집도가 '높다/낮다'로 표현
  - 훌륭한 설계는 응집도가 높은 설계
- 결합도
  - 모듈이 외부의 다른 모듈에 의존하는 정도
  - 모듈이 다른 모듈에 대해 알고 있는 지식의 양
  - 결합도가 '높다/낮다' 또는 '강하다/느슨하다'로 표현
  - 훌륭한 설계는 결합도가 낮은 설계
    - 결합도를 낮추기 위해 자주 변하지 않는 안정적인 부분에 의존한다.
    - 안정적인 부분은 추상화된 부분을 뜻하며, 추상클래스나 인터페이스가 될 수 있다.
- 캡슐화
  - 내부의 데이터와 메서드를 하나의 단위로 묶음
  - 외부로부터 데이터에 대한 직접적인 접근 제한
  - 공통 인터페이스를 통한 접근만 허용
  - 변경 관점에서의 캡슐화는 단순 데이터를 감추는 것이 아니라 변경되는 부분을 내부로 숨기는 추상화 기법으로도 볼 수 있다.
    - 데이터 변경으로 인한 파장을 차단할 수 있다.
    - 타입 변경으로 인한 파장을 차단할 수 있다.
- 설계의 핵심
  - 훌륭한 설계란 변경하기 쉽게 코드를 배치하는 것이다. 
  - 모든 설계 원칙과 이론은 변경과 관련되어있다.
    - Ex) SOLID 원칙
  - 디자인 패턴도 변경과 관련되어 있다.
    - Ex) 템플릿 메서드 패턴, 전략 패턴 등
  - 응집도, 결합도, 캡슐화 역시 변경과 관련되어 있다.